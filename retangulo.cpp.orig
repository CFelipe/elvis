#include "retangulo.h"
#include "vertice.h"
#include "objeto.h"

/*
 * O retângulo é definido por quatro vértices no sentido anti-horário:
 *
 * A-----------D
 * |           |
 * |           |
 * B-----------C
 */

Retangulo::Retangulo(Vertice A, Vertice B, Vertice C, Vertice D , GLfloat colorfill[4], GLfloat colorLine[4], GLint espessuraLinha, bool linha = true, bool preenchido = true) : Objeto(colorfill, colorLine, espessuraLinha, linha, preenchido, Objeto::RETANGULO) {
    this->A = Vertice(A.p.x, A.p.y);
    this->B = Vertice(B.p.x, B.p.y);
    this->C = Vertice(C.p.x, C.p.y);
    this->D = Vertice(D.p.x, D.p.y);
    Vertice m(A.p.x, A.p.y);
    min = m.p;
    max = m.p;
    Vertice c((max.x-min.x)/2 + min.x, (max.y- min.y)/2 + min.y);
    this->centro = c;
    this->tipo = Objeto::RETANGULO;
    this->isVisible = true;
    this->isSeletor = false;
}

<<<<<<< HEAD
void Retangulo::desenha() {
    if(isVisible==true){
        Bresenham(A, B);
        Bresenham(B, D);
        Bresenham(D, C);
        Bresenham(C, A);
    }
=======
void Retangulo::desenhaLinha() {
    Objeto::Bresenham(A.p, B.p);
    Objeto::Bresenham(B.p, D.p);
    Objeto::Bresenham(D.p, C.p);
    Objeto::Bresenham(C.p, A.p);
>>>>>>> cor
}

void Retangulo::desenhaFill() {
    GLint y, x_max, x_min, y_max, y_min;

<<<<<<< HEAD

    glPointSize(getEspessuraLinha()+10);
    glBegin(GL_POINTS);
        glVertex2i(max.x, max.y);
    glEnd();
    glPointSize(getEspessuraLinha()+5);
    glBegin(GL_POINTS);
        glVertex2i(min.x, min.y);
    glEnd();


    // Especifica o diâmetro do Vertice
    glPointSize(getEspessuraLinha());



    GLint x, y;
    if (p2.p.x!=p1.p.x && p2.p.y!=p1.p.y){
        GLfloat m = (GLfloat) (p2.p.y-p1.p.y) / (p2.p.x-p1.p.x);
        if (m>0  && m<1){

            GLint dx = p2.p.x - p1.p.x;
            GLint dy = p2.p.y - p1.p.y;
            GLint pk = 2*dy - dx;
            GLint dy_2 = 2*dy;
            GLint ddxy = dy_2 - 2*dx;
            x = p1.p.x;
            y = p1.p.y;
            glBegin( GL_POINTS );
                glVertex2i( (GLint)x, (GLint)y );
            glEnd( );
            if (p1.p.x<p2.p.x){
                while (x<p2.p.x){

                    x++;
                    if (pk<0) pk = pk+dy_2;
                    else {
                        y++;
                        pk = pk + ddxy;
                    }
                    glBegin( GL_POINTS );
                        glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            } else {
                while (x>p2.p.x){

                    x--;
                    if (pk<0) pk = pk-dy_2;
                    else {
                        y--;
                        pk = pk - ddxy;
                    }
                    glBegin( GL_POINTS );
                        glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            }
        } else if (m>-1 && m<0){
            printf("%f\n", m);
            GLint dx = p2.p.x - p1.p.x;
            GLint dy = - p2.p.y + p1.p.y;
            GLint pk = 2*dy + dx;
            GLint dy_2 = 2*dy;
            GLint ddxy = dy_2 - 2*dx;

            x = p1.p.x;
            y = p1.p.y;
            glBegin( GL_POINTS );
                glVertex2i( (GLint)x, (GLint)y );
            glEnd( );
            if (p1.p.x<p2.p.x){
                while (x<p2.p.x){
                    x++;
                    if (pk<0) pk = pk+dy_2;
                    else {
                        y--;
                        pk = pk + ddxy;
                    }
                    glBegin( GL_POINTS );
                        glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            } else {
                while (x>p2.p.x){
                    x--;
                    if (pk<0) pk = pk-dy_2;
                    else {
                        y++;
                        pk = pk - ddxy;
                    }
                    glBegin( GL_POINTS );
                        glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            }
        } else if (m>1){
            GLint dx = p2.p.x - p1.p.x;
            GLint dy = p2.p.y - p1.p.y;
            GLint pk = 2*dx + dy;
            GLint dx_2 = 2*dx;
            GLint ddxy = dx_2 - 2*dy;

            x = p1.p.x;
            y = p1.p.y;
            glBegin( GL_POINTS );
                glVertex2i( (GLint)x, (GLint)y );
            glEnd( );
            if (p1.p.y<p2.p.y){
                while (y<p2.p.y){
                    y++;
                    if (pk<0) pk = pk+dx_2;
                    else {
                        x++;
                        pk = pk + ddxy;
                    }
                    glBegin( GL_POINTS );
                        glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            } else {
                while (y>p2.p.y){
                    y--;
                    if (pk<0) pk = pk-dx_2;
                    else {
                        x--;
                        pk = pk - ddxy;
                    }
                    glBegin( GL_POINTS );
                        glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            }
        } else if (m<-1){
            GLint dx = p2.p.x - p1.p.x;
            GLint dy = -p2.p.y + p1.p.y;
            GLint pk = 2*dx - dy;
            GLint dx_2 = 2*dx;
            GLint ddxy = dx_2 - 2*dy;

            x = p1.p.x;
            y = p1.p.y;
            glBegin( GL_POINTS );
                glVertex2i( (GLint)x, (GLint)y );
            glEnd( );
            if (p1.p.y>p2.p.y){
                while (y>p2.p.y){
                    y--;
                    if (pk<0) pk = pk+dx_2;
                    else {
                        x++;
                        pk = pk + ddxy;
                    }
                    glBegin( GL_POINTS );
                        glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            } else {
                while (y<p2.p.y){
                    y++;
                    if (pk<0) pk = pk-dx_2;
                    else {
                        x--;
                        pk = pk - ddxy;
                    }
                    glBegin( GL_POINTS );
                        glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            }

        } else if (m==1){
            x = p1.p.x;
            y = (GLfloat) p1.p.y;
            glBegin( GL_POINTS );
                    glVertex2i( (GLint)x, (GLint)y );
            glEnd( );
            if (p1.p.y<p2.p.y){
                while (y<p2.p.y){
                    x++;
                    y++;
                    glBegin( GL_POINTS );
                            glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            } else {
                while (y>p2.p.y){
                    x--;
                    y--;
                    glBegin( GL_POINTS );
                            glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            }
        } else if (m==-1){
            x = p1.p.x;
            y = (GLfloat) p1.p.y;
            glBegin( GL_POINTS );
                    glVertex2i( (GLint)x, (GLint)y );
            glEnd( );
            if (p1.p.y>p2.p.y){
                while (y>p2.p.y){
                    x++;
                    y--;
                    glBegin( GL_POINTS );
                            glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            } else {
                while (y<p2.p.y){
                    x--;
                    y++;
                    glBegin( GL_POINTS );
                            glVertex2i( (GLint)x, (GLint)y );
                    glEnd( );
                }
            }
        }
    } else if (p2.p.y==p1.p.y){ //se a linha for horizontal:

        x = p1.p.x;
        y = (GLfloat) p1.p.y;
        glBegin( GL_POINTS );
            glVertex2i( (GLint)x, (GLint)y );
        glEnd( );
        if (p1.p.x<p2.p.x){
            while (x<p2.p.x){
                x++;

                glBegin( GL_POINTS );
                    glVertex2i( (GLint)x, (GLint)y );
                glEnd( );
            }
        } else {
            while (x>p2.p.x){
                x--;

                glBegin( GL_POINTS );
                    glVertex2i( (GLint)x, (GLint)y );
                glEnd( );
            }
        }
    } else { // se a linha for vertical:
        x = p1.p.x;
        y = (GLfloat) p1.p.y;
        glBegin( GL_POINTS );
            glVertex2i( (GLint)x, (GLint)y );
        glEnd( );
        if (p1.p.y<p2.p.y){
            while (y<p2.p.y){
                y++;
=======
    if(A.p.y < B.p.y) {
        y_min = A.p.y;
        y_max = B.p.y;
    } else {
        y_min = B.p.y;
        y_max = A.p.y;
    }
>>>>>>> cor

    if(A.p.x < D.p.x) {
        x_min = A.p.x;
        x_max = D.p.x;
    } else {
        x_min = D.p.x;
        x_max = A.p.x;
    }

    for(y = y_min; y <= y_max; y++) {
        Objeto::linhaFill(Ponto(x_min, y), Ponto(x_max, y));
    }
}

void Retangulo::escala(GLdouble fatorx, GLdouble fatory){
   Vertice *v[4] = {&A,&B, &C, &D};
    for (int i=0; i<4; i++){
        if (v[i]->p.x==max.x){
            v[i]->p.x = (v[i]->p.x+fatorx);
        } else if (v[i]->p.x==min.x){
            v[i]->p.x = (v[i]->p.x-fatorx);
        }
        if (v[i]->p.y == max.y){
            v[i]->p.y = (v[i]->p.y + fatory);
        } else if (v[i]->p.y == min.y){
            v[i]->p.y = (v[i]->p.y - fatory);
        }
    }

    atualizaMINMAX();
}

void Retangulo::atualizaMINMAX(){
    Vertice v[4] = {A, B, C, D};
    GLint maxx=A.p.x, maxy=A.p.y, minx = A.p.x, miny = A.p.y;
    for (int i=0; i<4; i++){
      if (v[i].p.x>maxx) maxx = v[i].p.x;
      if (v[i].p.y>maxy) maxy = v[i].p.y;
      if (v[i].p.x<minx) minx = v[i].p.x;
      if (v[i].p.y<miny) miny = v[i].p.y;
    }
    min.x = (minx);
    min.y = (miny);
    max.x = (maxx);
    max.y = (maxy);
    Ponto c((max.x-min.x)/2 + min.x, (max.y- min.y)/2 + min.y);
    this->centro = c;
}
